process {
   resourceLabels = {[
        uniqueRunId: System.getenv("TOWER_WORKFLOW_ID"),
        pipelineProcess: task.process.toString(),
        pipelineTag: task.tag.toString(),
        pipelineCPUs: task.cpus.toString(),
        pipelineMemory: task.memory.toString(),
        pipelineTaskAttempt: task.attempt.toString(),
        pipelineContainer: task.container.toString(),
        taskHash: task.hash.toString(),
        pipelineUser: workflow.userName.toString(),
        pipelineRunName: workflow.runName.toString(),
        pipelineSessionId: workflow.sessionId.toString(),
        pipelineResume: workflow.resume.toString(),
        pipelineRevision: workflow.revision.toString(),
        pipelineCommitId: workflow.commitId.toString(),
        pipelineRepository: workflow.repository.toString(),
        pipelineName: workflow.manifest.name.toString()
    ]}
}

aws.batch.maxSpotAttempts = 5
fusion.containerConfigUrl = 'https://fusionfs.seqera.io/releases/v2.4-snap_amd64.json'

// Note the largest machine is either a c6id.12xlarge with 48 cores and 96GB memory, OR a m6id.8xlarge with 32 cores or 128 GB of memory. 
// I've opted for m6id.8xlarge here on the basis people are more likely to need big memory than more CPUs
process.resourceLimits = [cpus: 32, memory: '128.GB', time: '16.h']